快手 安卓 二面
1. 大概讲一下你们业务型态和需求一般是怎么分类
2. 简单介绍一下你负责的页面架构和框架，如果要新增一个卡片样式，是什么流程
3. 新开发的卡片怎么保证性能和质量呢？有没有一个全局的检测或者收口，平时开发的时候怎么做质量和性能的准出？
4. 你们上报是通过什么方式检测的？如果是扫描屏幕视图数的话，那扫描的频率是多少呢？扫描每次耗时大概是多少？是在主线程还是在子线程扫描？
5. 继续介绍项目。。。。
6. JAVA的四种引用类型 和 使用场景
7. HashMap相关：
    1. 扩容过程介绍一下
    2. 扩容因子的目的是什么？我们可以自定义设置，设置大和设置小会有什么影响
    3. 什么时候会变成红黑树，变成红黑树的阈值是怎么得出来的
    4. 红黑树具体是否有了解？包括红黑树特性还有效率大概是怎么样的
    5. 算出hash值，怎么再映射到map的数组上的有了解吗？
8. recyclerView的实现原理有了解吗？大概讲一下过程吧
9. 换一个问法，在recyclerView里面基本用法是创建viewHolder还有绑定数据，它的调用频次是什么样的？在滑动过程中，分别什么时候会去调用这两个方法呢？以及复用的流程是怎么走的？
10. 假设现在一个页面里面有两个tab，每个tab各有一个recyclerView，里面的内容长得差不多，是否可以使用一个池子来做复用呢？
11. 算法题：合并区间 leetcode56


答案：
1.商业化（以赚钱为目的，运营，广告，活动），数据侧（数据上报，TAB实验），用户心智形态研发（提升DAU，用户粘性）
需求：技术/非技术

2.app形态很影响页面架构。腾讯视频是最大容器包含底部bar，底部bar每个item对应一个容器。首页这个容器里包含了一个屏幕等高，宽度无限，可横滑滚动的容器，每个垂直频道在这个横滑容器上占一个屏幕的size
对于同一个容器，这些垂直频道页面共用导航搜索。共用的组建放在容器与承载业务内容的容器互为平级兄弟视图。他们各自间的通信通过共同的父容器来实现。UI方面的框架，除了定制浮动view，剩下装入业务数据容器都是用UN框架。
所谓UN框架就是，将所有模块划分为module section block。由框架计算每个模块布局位置和大小，然后数据填充进相应的格子。

3.这个问题很关键，现在的模式是个团队各自分工，大家都只注重自己的UI是否实现效果和功能，很少关心，新加的内容会产生的性能影响，和内存占用。 如何保证，一个是可以靠自身经验，比如同一个文字多次计算，由每次用到就要计算不如用一些内存存储相同文本内容的计算结果。
高斯模糊图片处理，像素非必要不设置带小数点等等，同样也可以靠CR代码的时候被更有经验的同事指出。当然在开发周期允许的情况下，完全可以用Xcode自带的TimeProfile检查渲染耗时，分析火焰图，亦或者抓内存图看内存占用情况再进一步优化
我们有全局检测和收口，这个主工程里涵盖了卡顿上报，会将卡顿页面的信息，和方法耗时，调用堆栈，上报到性能平台，并可视化出来，一般会有专门的性能团队观察这些数据指标，然后根据堆栈找到开发者沟通。
质量靠开发者自测，双端会有互相自测的文档，性能除里依赖上述的工具反馈，平时也可以主动分析关注，尤其首页
和重要控件
bugly的卡顿做卡顿检测上报的原理是：两个定时器，在主子线程回调，然后时间戳做差，大于1s就上报卡顿，他是通过子线程抓的主线程堆栈上报。两个定时器回调时，分别取当前的时间戳，做差，如果主线程卡了，这个差就会变大，大于阈值就上报主线程卡了的话，定时器的回调就会等卡完了才能回调但此时子线程的定时器是一直有回调的

4.在每次runloopwaiting的时候扫描的,因为涉及扫描视图树，所以目前都是在主线程做的.所谓runloopWaiting主线程当前任务执行完了的时候，会进入runloopwaiting，本身就是一个空闲状态，但是如果扫描任务很耗时，就会将下一个loop的执行时机推迟了

5. Java中有四种引用类型，分别为强引用、软引用、弱引用和虚引用。
1. 强引用：最常见的引用类型，如果一个对象具有强引用，即使系统内存不足，垃圾回收器也不会回收该对象。
2. 软引用：如果一个对象只有软引用，那么当系统内存不足时，垃圾回收器就会回收该对象。可以使用SoftReference类来创建软引用。
3. 弱引用：如果一个对象只有弱引用，那么只要垃圾回收器扫描到该对象，便会回收该对象。可以使用WeakReference类来创建弱引用。
4. 虚引用：如果一个对象只有虚引用，那么该对象几乎等同于不存在，任何时候都可能被垃圾回收器回收。可以使用PhantomReference类来创建虚引用。

HashMap:
 在Java中，HashMap是一种哈希表实现的Map接口。它使用哈希算法来存储键值对，以便快速检索和插入数据。当HashMap中元素的数量达到负载因子（默认为0.75）与当前容量的乘积时，就会触发扩容操作。以下是HashMap的扩容过程：
1. 创建一个新的数组，其容量是原数组的两倍。
2. 将原数组中的元素逐个复制到新数组中。这个过程中，每个元素的索引会重新计算，以便适应新的数组大小。
3. 扩容完成后，所有插入到HashMap中的元素都需要重新计算哈希值，并插入到新的数组中。
4. 扩容过程中，如果有多个元素的哈希值相同，它们会被放到同一个链表中。在扩容后，这些链表中的元素也需要按照新的数组大小重新分配到不同的位置。
需要注意的是，由于扩容操作需要将原数组中的元素逐个复制到新数组中，因此它可能会比较耗时。在HashMap中，负载因子的大小会直接影响扩容的频率和效率。如果负载因子设置得太小，会导致HashMap的容量过大，浪费内存空间；如果负载因子设置得太大，又会导致扩容的频率过高，影响HashMap的性能。因此，在使用HashMap时，需要根据实际情况适当调整负载因子的大小。












